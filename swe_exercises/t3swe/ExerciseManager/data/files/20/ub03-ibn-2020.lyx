#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
%\usepackage[ngerman]{babel}
\usepackage{xspace}
\usepackage{caption}
\usepackage[autolanguage]{numprint}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{ifthen}
\usepackage{paralist}
\usepackage{scrpage2}
\usepackage{hyperref}
%\usepackage{libertine} 

\newcommand{\uebnr}{3}
\newcommand{\uebabgabe}{19.05.2020, 11:00 Uhr}

\newcommand{\uebdatum}{12.05.2020}
 
\newcounter{uebnummer}
\setcounter{uebnummer}{0}

\newcommand{\aufgabe}[1]{\stepcounter{uebnummer}\section*{Aufgabe \arabic{uebnummer} \hfill(#1 \ifthenelse{\equal{#1}{1}}{Punkt}{Punkte})}}

\pagestyle{scrheadings}

\ifoot{\footnotesize{\uebnr{}. Übung IBN -- SoSe 2020}}
\cfoot{}
\ofoot{\thepage}

%\newcommand{\befehl}[1]{"`\texttt{#1}"'\xspace}
\setlength{\parindent}{0pt} 
\end_preamble
\options headinclude,footinclude,DIV14,smallheadings,ngerman
\use_default_options false
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style polish
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Universität Heidelberg 
\begin_inset space \hfill{}
\end_inset

AG Parallele und Verteilte Systeme (PVS)
\begin_inset Newline newline
\end_inset

 Sommersemester 2020 
\begin_inset space \hfill{}
\end_inset

Artur Andrzejak
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size large
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
uebnr{}
\end_layout

\end_inset

.
 Übung zur Vorlesung 
\begin_inset Quotes gld
\end_inset

Betriebssysteme und Netzwerke
\begin_inset Quotes grd
\end_inset

 (IBN)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\series default
\size default

\begin_inset VSpace 2ex*
\end_inset

Abgabedatum: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
uebabgabe
\end_layout

\end_inset


\series bold
\size large

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\series default
\size default

\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100col%"
height "0.5pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Prozesse (Wiederholung): Process Control Block, fork 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{2}
\end_layout

\end_inset

In welcher Datei des Quelltextes des neuesten Linux-Kernels (ggf.
 in der Entwicklung) findet sich die Definition der Datenstruktur 
\family typewriter
task_struct
\family default
, die den Process Control Block enthält? Geben Sie die Kernel-Version, den
 Link zur Datei (oder die Datei selbst) sowie die Zeile an, wo Sie 
\family typewriter
task_struct
\family default
 gefunden haben.
 Schätzen Sie den Speicherbedarf dieser Datenstruktur, indem sie zur Vereinfachu
ng annehmen, dass jeder Eintrag (Variable, Pointer, interne 
\family typewriter
struct
\family default
 usw.) genau 8 Bytes belegt.
 Nehmen Sie zur weiteren Vereinfachung an, dass alle 
\family typewriter
#ifdef
\family default
 erfüllt sind.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{1}
\end_layout

\end_inset

Finden Sie heraus, was eine 
\emph on
fork-Bombe
\emph default
 ist.
 Was sind die 
\begin_inset Quotes pld
\end_inset

Zutaten
\begin_inset Quotes prd
\end_inset

? Was für Ressourcen sind betroffen und welche wird wahrscheinlich als erste
 ausgeschöpft? Falls sie experimentieren wollen, verwenden Sie am besten
 eine virtuelle Maschine, oder den Rechner Ihres Bruders.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Prozess-Synchronisation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{3}
\end_layout

\end_inset

Überlegen Sie, wie die Semaphor-Operationen wait() und signal() auf Mehrprozesso
r-Systemen mit Hilfe der Hardware-Befehle TSL bzw.
 XCHG umgesetzt werden können.
 Schreiben Sie die Lösung als einen C-ähnlichen Pseudocode auf.
 Ihre Lösung sollte das aktive Warten (d.h.
 das Ausführen einer Warteschleife) möglichst kurz halten.
 Hierbei wird die Operation TSL als Funktion 
\family typewriter
boolean TestAndSet(boolean *target)
\family default
 dargestellt, bzw.
 die Operation XCHG als Funktion 
\family typewriter
void Swap(boolean *a, boolean *b)
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{6}
\end_layout

\end_inset

Das in der Vorlesung erwähnte Erzeuger-Verbraucher-Problem (englisch: Producer-C
onsumer Problem) ist ein klassisches Synchronisationsproblem.
 Ein Erzeuger generiert Aufgaben und legt diese in einem Puffer mit fester
 Größe ab.
 Der Verbraucher entnimmt Aufgaben (oder Daten) aus dem Puffer und arbeitet
 diese ab.
 Für eine korrekte Arbeitsweise muss sichergestellt werden, dass nur jeweils
 ein Erzeuger oder ein Verbraucher auf den gemeinsamen Puffer zugreifen
 kann (mutual exclusion).
 Außerdem ist es wichtig, dass Erzeuger nur dann Aufgaben im Puffer ablegen,
 wenn auch Platz vorhanden ist.
 Für die Verbraucher gilt, dass sie keine Aufgaben entnehmen können, wenn
 der Puffer leer ist.
 Angewendet wird das Erzeuger-Verbraucher-Muster z.B.
 bei Webservern, bei denen der Erzeuger die Anfragen (requests) der Clients
 annimmt und die Verbraucher diese Anfragen dann befriedigen (z.B.
 Suchen und Zurücksenden der angefragten Seite).
 
\end_layout

\begin_layout Standard
Im heibox-Verzeichnis mit den Übungsblättern finden Sie eine Dateiarchiv
 namens ub03-ibn-code-pc.zip, welches eine C-Implementierung des Erzeuger-
 Verbraucher-Problems enthält.
 In diesem Beispiel legt ein Produzent Aufgaben in einen Puffer ab und mehrere
 Konsumenten arbeiten diese danach ab.
 Die Datei mylist.h enthält diverse Definitionen, wie z.B.
\end_layout

\begin_layout LyX-Code
#define NUM_CONSUMER 10
\end_layout

\begin_layout LyX-Code
#define MAX_COUNT 20
\end_layout

\begin_layout LyX-Code
#define FIBONACCI_MAX 40
\end_layout

\begin_layout LyX-Code
#define MAX_QUEUE_LENGTH 5
\end_layout

\begin_layout Standard
In unserem Fall werden also 10 Konsumenten (
\family typewriter
NUM_CONSUMER
\family default
) gestartet.
 Der Produzent generiert 20 Aufgaben (
\family typewriter
MAX_COUNT
\family default
).
 Eine Aufgabe ist eine Berechnung der 
\begin_inset Formula $n$
\end_inset

-ten Fibonacci-Zahl, wobei hier 
\begin_inset Formula $n=40$
\end_inset

 ist (
\family typewriter
FIBONACCI_MAX
\family default
).
 Die Größe des Puffers wird auf 5 Aufgaben beschränkt (
\family typewriter
MAX_QUEUE_LENGTH
\family default
).
\end_layout

\begin_layout Standard
In der Implementierung in pc.c wartet der Produzent sowie jeder Konsument
 aktiv auf die Möglichkeit Daten hineinzustellen oder zu entnehmen.
 In der pthread-Bibliothek gibt es auch die Möglichkeit, Zustandsvariablen
 (condition variables) zu verwenden, um aktives Warten zu vermeiden.
 Wenn also z.B.
 der Produzent einen vollen Puffer vorfindet, legt er sich schlafen (wait)
 und wartet dabei auf ein Signal der Konsumenten (signal).
 Wie in der Vorlesung erläutert, ist das allgemeine Vorgehen mit einer Sperre
 
\family typewriter
mutex
\family default
 und einer Zustandsvariablen 
\family typewriter
cond_var
\family default
 damit wie folgt:
\end_layout

\begin_layout LyX-Code
lock mutex
\end_layout

\begin_layout LyX-Code
while( ! condition ) {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
cond_wait( cond_var, mutex )
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
// mach etwas mit dem Puffer
\end_layout

\begin_layout LyX-Code
unlock mutex
\end_layout

\begin_layout Description
a)
\begin_inset space ~
\end_inset

(5
\begin_inset space ~
\end_inset

Punkte) Verändern Sie das angegebene Programm pc.c so, dass sich der Produzent
 schlafen legt, wenn der Puffer voll ist.
 Analog soll sich jeder Konsument schlafen legen, wenn der Puffer leer ist.
 Wenn der Produzent 
\family typewriter
MAX_COUNT
\family default
 viele Aufgaben erzeugt hat, setzt er das Flag 
\family typewriter
production_done
\family default
 und beendet sich.
 Somit können sich die Konsumenten auch beenden, sobald 
\family typewriter
production_done
\family default
 gesetzt ist.
 
\begin_inset Newline newline
\end_inset

Achten sie auch darauf, dass zwei Funktionen zum Aufwecken der Threads zur
 Verfügung gestellt werden: 
\family typewriter
pthread_cond_signal
\family default
(..) und 
\family typewriter
pthread_cond_broadcast
\family default
(..).
 Möchten Sie also mehr als einen wartenden Thread wecken, ist 
\family typewriter
pthread_cond_broadcast
\family default
(..).
 vorzuziehen.
 Nennen Sie das veränderte Programm pc2.c und reichen Sie es ein.
\end_layout

\begin_layout Description
b)
\begin_inset space ~
\end_inset

(1
\begin_inset space ~
\end_inset

Punkt) Messen Sie die Laufzeiten von pc.c und pc2.c.
 Geben Sie dazu die mittlere Laufzeit pro Programm für jeweils zehn Durchläufe
 an.
 Erläutern Sie Ihre Ergebnisse.
\end_layout

\begin_layout Description
Hinweis Im Archiv finden Sie ein Makefile.
 Für pc2.c sind nur die Kommentare der entsprechenden Teile zu entfernen.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
IPC: Shared Memory
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{2}
\end_layout

\end_inset

Fügen Sie in das folgende Programm für die Platzhaltern 
\family typewriter
???
\family default
 geeignet folgende Befehle ein: 
\family typewriter
shmat, shmctl, shmdt, shmget
\family default
.
 Erklären Sie jeden der Befehle kurz.
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include <sys/types.h>
\end_layout

\begin_layout LyX-Code
#include <sys/ipc.h>
\end_layout

\begin_layout LyX-Code
#include <sys/shm.h>
\end_layout

\begin_layout LyX-Code
#include <sys/wait.h>
\end_layout

\begin_layout LyX-Code
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code
int main(){
\end_layout

\begin_deeper
\begin_layout LyX-Code
int i, shmID, *shared_mem, count=0, total=0,rnd;
\end_layout

\begin_layout LyX-Code
shmID = ???(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0644);
\end_layout

\begin_layout LyX-Code
shared_mem = (int*)???(shmID,0,0);
\end_layout

\begin_layout LyX-Code
*shared_mem = 0;
\end_layout

\begin_layout LyX-Code
if (fork())
\end_layout

\begin_deeper
\begin_layout LyX-Code
for (i=0; i<500; i++){
\end_layout

\begin_deeper
\begin_layout LyX-Code
*shared_mem+=1;
\end_layout

\begin_layout LyX-Code
printf("
\backslash
n Elternprozess: %i", *shared_mem);
\end_layout

\begin_layout LyX-Code
sleep(2);
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
else
\end_layout

\begin_deeper
\begin_layout LyX-Code
for (i=0; i<500;i++){
\end_layout

\begin_deeper
\begin_layout LyX-Code
*shared_mem+=1;
\end_layout

\begin_layout LyX-Code
printf("
\backslash
n Kindprozess: %i", *shared_mem);
\end_layout

\begin_layout LyX-Code
rnd=rand();
\end_layout

\begin_layout LyX-Code
sleep(rnd%3);
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
???(shared_mem);
\end_layout

\begin_layout LyX-Code
???(shmID, IPC_RMID, 0);
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Kompilieren Sie das Programm und führen es aus.
 Welches Verhalten können Sie beobachten (ist dies wie erwartet)? Fügen
 Sie eine Ausgabe von einem ggf.
 merkwürdigen Programmlauf bei.
 Versuchen Sie Ihre Beobachtungen zu erklären.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
IPC: Pipes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
aufgabe{2}
\end_layout

\end_inset

Shells wie Bash erlauben die Verwendung von benannten Pipes.
 
\end_layout

\begin_layout Description
a.
 Benennen Sie mindestens ein 
\emph on
Nachteil
\emph default
 der benannten Pipes im Vergleich zu den anonymen Pipes.
\end_layout

\begin_layout Description
b.
 Schreiben Sie das Beispiel aus der Vorlesung (Zählen von *.jpg-Dateien)
 so um, dass ein benanntes Pipe verwendet wird.
\end_layout

\begin_layout Description
c.
 Geben Sie ein eigenes Beispiel für die Verwendung von benannten Pipes (in
 der Shell) an, bei dem die anonymen Pipes nicht ausreichen.
 Sie müssen keinen Shell-Code angeben; allerdings soll das ein eigenes Beispiel
 sein (insbesondere nicht im Internet auffindbar).
\end_layout

\end_body
\end_document
